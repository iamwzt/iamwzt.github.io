`ReentrantLock`实现了`Lock`，有一个继承了`AQS`的内部抽象类`Sync`，并有两个内部实现类，分别是公平锁实现`FairSync`和非公平锁实现`NonfairSync`。

采用了模板设计模式。

#### `ReentrantLock`的`lock()`方法
```java
public void lock() {
    sync.lock();
}
```
#### `Sync`的`lock()`方法
在这里 **公平锁和非公平锁出现了第一个不同**：非公平锁会立刻去抢一次锁，失败了才走正常流程
```java
// FairSync实现的 
final void lock() {
    acquire(1);
}

// NonfairSync实现的 
final void lock() {
    // 先抢一下，失败了才走正常流程
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
```

#### `AQS`的`acquire()`方法
```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```
`tryAcquire()`方法需要实现类自己去实现，在公平锁中，是这样的：
```java
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        // 当前锁是可以用的，但是得先看看队列中是否已有其他等待者的waiter了
        if (!hasQueuedPredecessors() &&
            // 试着CAS抢一下锁，抢不到说明被其他线程抢先了（不是队列里的，队列里没有线程）
            compareAndSetState(0, acquires)) {
            // 抢到了就标记当前锁的占有者是本线程
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    // 进到这个分支就代表是重入了，当前独占锁的线程就是本次要来获取的线程
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```
`hasQueuedPredecessors`方法判断队列中是否有其他等待者：
```java
// 有两种情况会导致返回false:
// 1. 头节点 == 尾节点，说明队列还是空的，头节点还没被初始化；
// 2. 等待队列中没有其他线程等待
public final boolean hasQueuedPredecessors() {
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
    // 头节点和尾节点
    return h != t &&
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
```
再来看看非公平锁的实现：这里*和公平锁有第二个不同*，锁可用时不管队列里有没有排队的，先抢一波试试
```java
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        // 发现锁可用，就先抢一波
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

这里回到`AQS`的`acquire`方法，`tryAcquire`失败后，就要乖乖排队了。<br/>
`AQS`的`addWaiter`方法：
```java
private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    Node pred = tail;
    // 若为null，说明头节点还没有初始化
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    // 失败的原因有2：
    // 1. 头节点还没有初始化
    // 2. 其他线程抢先了
    enq(node);
    return node;
}
```
`enq`方法：
```java
private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        // 这是失败原因1：头节点未初始化
        // 初始化完了进入下个循环，再入队
        if (t == null) { // Must initialize
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            // 这里是和addWaiter里一样的，只不过是自旋去入队
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

正常情况下，到这里就已经成功入队了，然后回到`AQS`的`acquire`方法：
```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```
在`acquireQueued`方法中，将完成排队获取锁的操作：
```java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            // 若前置节点是head，可以去尝试获取锁
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            // 要么前置节点不是head，要么获取失败
            if (shouldParkAfterFailedAcquire(p, node) &&
                // 挂起线程
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```
`shouldParkAfterFailedAcquire`方法判断是否要挂起当前线程：
```java
// pred为node的前置节点
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    // 若前置节点的等待状态时SIGNAL(-1)，则可以安全挂起
    if (ws == Node.SIGNAL)
        return true;
    // 前置节点的等待状态大于0（只有CANCEL大于0），则向前找，直到找到一个不大于0的
    if (ws > 0) {
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        pred.next = node;
    } else {
        // 前置节点等待状态为0或者PROPAGATE，这时CAS去设置为SIGNAL，但是不立刻就挂起
        // PROPAGATE先不谈，为何为0呢？
        // 所以每个新的node入队时，waitStatu都是0
        // 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0
        // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    // 为何不挂起？有可能经过刚才的向前找合适的前驱节点后，当前节点已经是head的直接后继节点了，就不需要挂起了
    return false;
}
```
简单以一个流程图总结一下：<br>
![这里有图](https://github.com/iamwzt/iamwzt.github.io/blob/master/img/AQS/AQS-acquire.png?raw=true)
