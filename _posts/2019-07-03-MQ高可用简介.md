---
layout:     post
title:      MQ高可用简介
subtitle:   
date:       2019-07-03
author:     iamwzt
header-img: img/home-bg-o.jpg
catalog: true
tags:
    - mq
    - HA
---
## RabbitMQ的高可用性
先说结论：采用`集群+镜像队列`的方式提高可用性
### 集群模式
在rabbitMQ的集群模式下，集群中所有节点**都会备份所有的元数据信息**，包括：
1. 队列元数据：队列名称和属性
2. 交换器元数据：交换器名称和属性
3. 绑定关系元数据：队列和交换机的绑定关系
4. vhost元数据：为其内的上三者提供命名空间和安全属性

**但是！！！不会备份消息数据！！！**

创建队列时，会在指定节点上创建队列进程并包含完整的所有信息，而其他节点只有元数据和指向该节点的指针。<br>
而交换器只是一个名称和绑定列表，创建新交换器只需将绑定列表添加到所有节点。<br/>

这就导致，若想消费某个队列的数据，有两种方式：
1. 消费者连接在非创建队列的那个节点，就需要从创建队列的节点拉取数据，有一定的**数据拉取的开销**；
2. 消费者固定连接在创建队列的节点，那么就存在**单实例的性能瓶颈**，集群也没意义了。

此外，若创建队列的节点宕机，其他节点也无法拉取数据了，消息会丢失；
若开启了消息持久化（消息、队列、交换器都持久化），那也要等节点恢复后才能继续拉取。

因此，该集群方式主要是为了**提高吞吐**，并没有什么高可用性。

### 镜像队列（Mirror Queue）
将队列镜像到其他Broker上，一旦一个节点失效，队列能自动切换到集群的其他节点上，以保证服务的可用性。

通常配置了镜像队列的集群中的节点会分为**一主多从**的结构，消息被发布到主节点上，会根据*策略*，手动或自动地同步到从节点上；

若主节点挂掉了，“资历最老”（加入时间最长）的从节点会被提升为新的主节点
