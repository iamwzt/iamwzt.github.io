### 消息不可达怎么办
1. `mandatory`：交换器无法根据自身类型和路由键找到一个符合条件的队列时，若该参数为true，则返回消息给生产者；
2. `immediate`：交换机将消息路由到队列时没有发现消费者时将不入队，所有队列都没有消费者，若该参数为true，则返回给生产者；
3. `备份交换机`：给一个交换机A声明一个备份交换机B，无法正确被A路由的消息将到B中去

如果上面三个都不设置，那么消息将会丢失。

### 过期时间（TTL）
1. 消息的TTL
    1. 由队列统一设置，不设置不过期，设置为0则和`immediate`有点像，只是不会返回消息；
    2. 单条消息设置TTL
2. 队列的TTL

在消息的TTL中，若由队列统一设置，则过期后会被定期删除（都在队头）；若由单条消息单独设置，则直到要投递时才去检查并删除。

### 死信队列
死信交换器绑定的队列便是死信队列。

死信有几种可能：
1. 消息被拒绝，且 `requeue` 被设置为false；
2. 消息过期；
3. 队列满。

可以为常规的队列设置**死信交换器**和**死信路由键**。若消息由于上述几种原因变成了死信，便会被放到死信交换器中，并投到绑定的队列里。

### 延迟队列
RabbitMQ并不直接支持延迟队列，但可通过**设置消息TTL+死信队列**来达到这一目的。
1. 为多个队列设置不同的TTL时间；
2. 为这些队列配置不同的死信交换器；
3. 消费者订阅绑定不同死信交换器的死信队列。

### 优先级队列
设置队列的最大优先级，然后消息的优先级范围为（0 ~ 队列的最大优先级）

### 持久化
持久化分三种：
1. 交换器（元数据）的持久化；
2. 队列（元数据）的持久化；
3. 消息的持久化

仅仅设置持久化不能保证消息的100%不丢失，还需要以下几个操作：
1. 消费者取消自动应答（autoAck），处理完消息后再手动应答；
2. MQ服务器端在数据落盘前宕机会导致消息丢失，可配置**镜像队列**；
3. 对于生产者来说，也需要保证消息能正确发送并存储在服务器端，一般采用**事务**或**应答**的方式去保证（见下）。

### 生产者确认
#### 事务机制
> `channel.txSelect`开启事务，`channel.txCommit`提交事务，`channel.txRollback`事务回滚

事务的流程：
1. 生产者：txSelect
2. 服务端：txSelect.OK
3. 生产者：publish
4. 生产者：txCommit/txRollback
5. 服务端：txCommit.OK/txRollback.OK

问题很明显，串行的，吞吐大大降低

#### 应答机制
生产者将信道设置为 `comfirm` 模式后，在该信道上发布的消息都有一个唯一的ID。
一旦消息被投递到队列上（如果是持久化的就是落盘后），将发送个包含此消息ID的确认信息给生产者。
也可设置成批量确认的模式，某个ID的消息被确认，就代表在此之前的都被确认了。

如果是同步确认，那么比事务也好不到哪去。此时有两种优化方式：
1. 异步确认（推荐）
2. 批量确认

### 惰性队列

### 镜像队列
想要RabbitMQ高可用（HA），那么就必须要**集群+镜像队列**

针对每一个配置镜像的队列，都有一主多从的配置（此处的主从是对队列而言的）

消费者和从队列建立订阅关系，看似是从从队列取消息，实质都是从队列向主队列获取数据，然后才投递给消费者的。

因此从单一一个队列来讲，并没有分担读写压力。但可通过在集群中均匀分布主队列的方式来实现负载均衡。

这里不同于MySQL数据库的读写分离机制。

线上配置：
```
{"ha-mode":"all","ha-sync-mode":"automatic","ha-promote-on-shutdown":"always"}
```
- 所有队列都镜像（对排他型的无效）
- 消息同步方式：自动
- 只要主队列挂了，从队列都会晋升为主队列
